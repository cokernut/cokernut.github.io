
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>React Native 学习笔记--基础知识 | Cokernut</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="React Native 基础知识学习">
<meta property="og:type" content="article">
<meta property="og:title" content="React Native 学习笔记--基础知识">
<meta property="og:url" content="http://cokernut.top/2016/12/01/ReactNative/React Native学习笔记--基础知识/index.html">
<meta property="og:site_name" content="Cokernut">
<meta property="og:description" content="React Native 基础知识学习">
<meta property="og:updated_time" content="2016-12-02T07:28:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Native 学习笔记--基础知识">
<meta name="twitter:description" content="React Native 基础知识学习">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Cokernut</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <font size="5">
            <a class="main-nav-link" href="/">主页</a>
          </font>
        
          <font size="5">
            <a class="main-nav-link" href="/archives">目录</a>
          </font>
        
      </nav>
      <nav id="sub-nav">
        
        <!--取消搜索框<a id="nav-search-btn" class="nav-icon" title="Search"></a>-->
      </nav>
      <!--取消搜索框
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="cokernut.top">
        </form>
      </div>
      -->
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-ReactNative/React Native学习笔记--基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/01/ReactNative/React Native学习笔记--基础知识/" class="article-date">
  <time datetime="2016-11-30T16:00:00.000Z" itemprop="datePublished">2016-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React-Native/">React Native</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      React Native 学习笔记--基础知识
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React Native 基础知识学习<br><a id="more"></a></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRegistry, Text &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 注册应用(registerComponent)后才能正确渲染</div><div class="line"> * 注意：一般在整个应用里AppRegistry.registerComponent这个方法只会调用一次，</div><div class="line"> * 而不是每个组件/模块都注册</div><div class="line"> * 注意，这里用引号括起来的'HelloWorldApp'必须和你init创建的项目名一致</div><div class="line"> */</div><div class="line">AppRegistry.registerComponent(<span class="string">'HelloWorldApp'</span>, () =&gt; HelloWorld);</div></pre></td></tr></table></figure>
<h2 id="Props-属性-、State-状态-、Style-样式"><a href="#Props-属性-、State-状态-、Style-样式" class="headerlink" title="Props(属性)、State(状态)、Style(样式)"></a>Props(属性)、State(状态)、Style(样式)</h2><p>大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props（属性）。</p>
<p>以常见的基础组件Image为例，在创建一个图片时，可以传入一个名为source的prop来指定要显示的图片的地址，<br>以及使用名为style的prop来控制其尺寸。</p>
<p>自定义的组件也可以使用props。通过在不同的场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。<br>只需在render函数中引用this.props，然后按需处理即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  Image,</div><div class="line">  View</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTextView</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">showText</span>: <span class="literal">true</span>&#125;; <span class="comment">//初始化state（状态）</span></div><div class="line">    <span class="comment">// 每1000毫秒对showText状态做一次取反操作</span></div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">showText</span>: !<span class="keyword">this</span>.state.showText&#125;) <span class="comment">//调用setState方法修改state的值</span></div><div class="line">    &#125;, <span class="number">10000</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">let</span> temp = <span class="string">'Name: '</span> + <span class="keyword">this</span>.props.name + <span class="string">'  Age: '</span> + <span class="keyword">this</span>.props.age + <span class="string">'!'</span>; <span class="comment">//取属性值并拼装</span></div><div class="line">    <span class="keyword">let</span> text = <span class="keyword">this</span>.state.showText ? temp : <span class="string">''</span>; </div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.text&#125;</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">let</span> pic=&#123;</div><div class="line">      <span class="attr">uri</span>:<span class="string">'http://file26.mafengwo.net/M00/25/15/wKgB4lIre0yAC1WOAAFKo9uhzX063.rbook_comment.w300.jpeg'</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * props,state,style</div><div class="line">       * </div><div class="line">       * style属性可以是一个普通的JavaScript对象,</div><div class="line">       * 你可以传入一个数组——在数组中位置居后的样式对象比居前的优先级更高，这样你可以间接实现样式的继承。</div><div class="line">       * 常见的做法是按顺序声明和使用style属性，以借鉴CSS中的“层叠”做法（即后声明的属性会覆盖先声明的同名属性）。</div><div class="line">       * </div><div class="line">       * 传值到Image的source属性，并定义样式</div><div class="line">       * 属性传值，this.props.propsname调用</div><div class="line">       */</div><div class="line">      &lt;View&gt;</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;[styles.text,</span> <span class="attr">styles.gray</span>, &#123;<span class="attr">fontSize:</span> <span class="attr">30</span>&#125;]&#125;&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></div><div class="line">        &lt;Image source=&#123;pic&#125; style=&#123;&#123;<span class="attr">width</span>:<span class="number">100</span>, <span class="attr">height</span>:<span class="number">100</span>&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span></div><div class="line">        &lt;MyTextView name=<span class="string">'Tom'</span> age=<span class="string">'16'</span>/&gt; </div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">MyTextView</span> <span class="attr">name</span>=<span class="string">'Joy'</span> <span class="attr">age</span>=<span class="string">'18'</span>/&gt;</span></span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</div><div class="line">  <span class="attr">text</span>: &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'green'</span>,</div><div class="line">    <span class="attr">fontSize</span>: <span class="number">20</span>,</div><div class="line">    <span class="attr">fontWeight</span>: <span class="string">'bold'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">gray</span>: &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'gray'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(<span class="string">'ReactNativeDemo'</span>, () =&gt; Root);</div></pre></td></tr></table></figure>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="指定宽高："><a href="#指定宽高：" class="headerlink" title="指定宽高："></a>指定宽高：</h3><p>最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。 React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。</p>
<h3 id="弹性（Flex）宽高："><a href="#弹性（Flex）宽高：" class="headerlink" title="弹性（Flex）宽高："></a>弹性（Flex）宽高：</h3><p>在组件样式中使用flex可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。<br>如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，<br>谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。  </p>
<font color="#D96060">注意：<br>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，<br>也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRegistry, View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="comment">// 试试去掉父View中的`flex: 1`。</span></div><div class="line">      <span class="comment">// 则父View不再具有尺寸，因此子组件也无法再撑开。</span></div><div class="line">      <span class="comment">// 然后再用`height: 300`来代替父View的`flex: 1`试试看？</span></div><div class="line">      &lt;View style=&#123;&#123;<span class="attr">flex</span>: <span class="number">1</span>&#125;&#125;&gt;</div><div class="line">        &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt;</div><div class="line">        &lt;View style=&#123;&#123;flex: 2, backgroundColor: 'skyblue'&#125;&#125; /&gt;</div><div class="line">        &lt;View style=&#123;&#123;flex: 3, backgroundColor: 'steelblue'&#125;&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AppRegistry.registerComponent('ReactNativeDemo', () =&gt; Root);</div></pre></td></tr></table></figure>
<h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><h3 id="flexDirection"><a href="#flexDirection" class="headerlink" title="flexDirection:"></a>flexDirection:</h3><p>决定布局的主轴，默认值是column(竖直轴，起点在顶部)，而不是row(水平轴，起点在左端)</p>
<h3 id="alignItems"><a href="#alignItems" class="headerlink" title="alignItems:"></a>alignItems:</h3><p>交叉轴的对齐方式，默认值是stretch  </p>
<ul>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中心对齐</li>
<li>stretch: 容器中的所有项目拉伸填满整个容器  </li>
</ul>
<h3 id="alignSelf"><a href="#alignSelf" class="headerlink" title="alignSelf:"></a>alignSelf:</h3><p>当前组件交叉轴的对齐方式，会覆盖的父组件的alignItems属性</p>
<h3 id="justifyContent"><a href="#justifyContent" class="headerlink" title="justifyContent:"></a>justifyContent:</h3><p>可以决定其子组件沿着主轴的对齐方式，默认值是flex-start  </p>
<ul>
<li>flex-start：主轴起点对齐</li>
<li>flex-end：主轴终点</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around: 每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h3 id="flexWrap"><a href="#flexWrap" class="headerlink" title="flexWrap:"></a>flexWrap:</h3><p>flexWrap属性定义一条轴线排不下时是否折行。它有两个值，分别是’wrap’和’nowrap’，分别代表支持换行和不支持换行，默认是’nowrap’。</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex:"></a>flex:</h3><p>只能指定一个数字值，这个属性可能使属性justifyContent失效。</p>
<h3 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h3><table>
<thead>
<tr>
<th>属性</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>alignItems    交叉轴的对齐方式</td>
<td>enum(‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’) </td>
</tr>
<tr>
<td>alignSelf 组件交叉轴的对齐方式</td>
<td>enum(‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’) </td>
</tr>
<tr>
<td>borderBottomWidth 下边框宽度</td>
<td>number </td>
</tr>
<tr>
<td>borderLeftWidth   左边框宽度</td>
<td>number </td>
</tr>
<tr>
<td>borderRightWidth  右边框宽度</td>
<td>number </td>
</tr>
<tr>
<td>borderTopWidth    上边框宽度</td>
<td>number </td>
</tr>
<tr>
<td>borderWidth        边框宽度</td>
<td>number </td>
</tr>
<tr>
<td>bottom         覆盖下边缘宽度</td>
<td>number </td>
</tr>
<tr>
<td>flex              权重</td>
<td>number </td>
</tr>
<tr>
<td>flexDirection     主轴</td>
<td>enum(‘row’, ‘column’) </td>
</tr>
<tr>
<td>flexWrap          是否折行</td>
<td>enum(‘wrap’, ‘nowrap’) </td>
</tr>
<tr>
<td>height            高度</td>
<td>number </td>
</tr>
<tr>
<td>justifyContent 主轴的排列方式</td>
<td>enum(‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’) </td>
</tr>
<tr>
<td>left           覆盖左边缘宽度</td>
<td>number </td>
</tr>
<tr>
<td>margin         组件外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginBottom   组件下外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginHorizontal 组件横向外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginLeft     组件左外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginRight    组件右外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginTop       组件上外边距</td>
<td>number </td>
</tr>
<tr>
<td>marginVertical  组件竖向外边距</td>
<td>number </td>
</tr>
<tr>
<td>padding        组件内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingBottom  组件下内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingHorizontal 组件横向内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingLeft    组件左内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingRight   组件右内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingTop     组件上内边距</td>
<td>number </td>
</tr>
<tr>
<td>paddingVertical 组件竖向内边距</td>
<td>number </td>
</tr>
<tr>
<td>position 位置属性 默认relative</td>
<td>enum(‘absolute’, ‘relative’)(绝对位置，相对位置) </td>
</tr>
<tr>
<td>right       覆盖右边缘宽度</td>
<td>number </td>
</tr>
<tr>
<td>top         覆盖上边缘宽度</td>
<td>number </td>
</tr>
<tr>
<td>width           宽度</td>
<td>number </td>
</tr>
<tr>
<td>zIndex   元素的堆叠顺序（z轴）</td>
<td>number</td>
</tr>
</tbody>
</table>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>accessibilityLabel string </p>
</blockquote>
<p>设置当用户与此元素交互时，“读屏器”（对视力障碍人士的辅助功能）阅读的文字。默认情况下，这个文字会通过遍历所有的子元素并累加所有的文本标签来构建。</p>
<blockquote>
<p>accessible bool </p>
</blockquote>
<p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p>
<blockquote>
<p>onAccessibilityTap function </p>
</blockquote>
<p>当accessible为true时，如果用户对一个已选中的无障碍元素做了一个双击手势时，系统会调用此函数。（译注：此事件是针对残障人士，并非是一个普通的点击事件。如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数）。</p>
<blockquote>
<p>onLayout function </p>
</blockquote>
<p>当组件挂载或者布局变化的时候调用，参数为：<br>{nativeEvent: { layout: {x, y, width, height}}}<br>这个事件会在布局计算完成后立即调用一次，不过收到此事件时新的布局可能还没有在屏幕上呈现，尤其是一个布局动画正在进行中的时候。</p>
<blockquote>
<p>onMagicTap function </p>
</blockquote>
<p>当accessible为true时，如果用户做了一个双指轻触(Magic tap)手势，系统会调用此函数。</p>
<blockquote>
<p>onResponderGrant function </p>
</blockquote>
<p>对于大部分的触摸处理，你只需要用TouchableHighlight或TouchableOpacity包装你的组件。</p>
<blockquote>
<p>pointerEvents enum(‘box-none’, ‘none’, ‘box-only’, ‘auto’) </p>
</blockquote>
<p>用于控制当前视图是否可以作为触控事件的目标。<br>auto：视图可以作为触控事件的目标。<br>none：视图不能作为触控事件的目标。<br>box-none：视图自身不能作为触控事件的目标，但其子视图可以。<br>box-only：视图自身可以作为触控事件的目标，但其子视图不能。  </p>
<blockquote>
<p>removeClippedSubviews bool </p>
</blockquote>
<p>这是一个特殊的性能相关的属性，由RCTView导出。在制作滑动控件时，如果控件有很多不在屏幕内的子视图，会非常有用。</p>
<p>要让此属性生效，首先要求视图有很多超出范围的子视图，并且子视图和容器视图（或它的某个祖先视图）都应该有样式overflow: hidden。</p>
<blockquote>
<p>style<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Flexbox...</div><div class="line">ShadowProp#style...</div><div class="line">Transforms...</div><div class="line">backfaceVisibility enum(&apos;visible&apos;, &apos;hidden&apos;)</div><div class="line">backgroundColor string</div><div class="line">borderColor string</div><div class="line">borderTopColor string</div><div class="line">borderRightColor string</div><div class="line">borderBottomColor string</div><div class="line">borderLeftColor string</div><div class="line">borderRadius number</div><div class="line">borderTopLeftRadius number</div><div class="line">borderTopRightRadius number</div><div class="line">borderBottomLeftRadius number</div><div class="line">borderBottomRightRadius number</div><div class="line">borderStyle enum(&apos;solid&apos;, &apos;dotted&apos;, &apos;dashed&apos;)</div><div class="line">borderWidth number</div><div class="line">borderTopWidth number</div><div class="line">borderRightWidth number</div><div class="line">borderBottomWidth number</div><div class="line">borderLeftWidth number</div><div class="line">opacity number</div><div class="line">overflow enum(&apos;visible&apos;, &apos;hidden&apos;)</div><div class="line">elevation number</div><div class="line">(限Android)使用Android原生的 elevation API来设置视图的高度（elevation）。</div><div class="line">这样可以为视图添加一个投影，并且会影响视图层叠的顺序。此属性仅支持Android5.0及以上版本。</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>在React Native中你必须把你的文本节点放在<text>组件内。你不能直接在<view>下放置一段文本。</view></text></p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>numberOfLines number </p>
</blockquote>
<p>用来当文本过长的时候裁剪文本。包括折叠产生的换行在内，总的行数不会超过这个属性的限制。</p>
<blockquote>
<p>onLayout function </p>
</blockquote>
<p>当挂载或者布局变化以后调用，参数为如下的内容：</p>
<p>{nativeEvent: {layout: {x, y, width, height}}}</p>
<blockquote>
<p>onLongPress function </p>
</blockquote>
<p>当文本被长按以后调用此回调函数。</p>
<blockquote>
<p>onPress function </p>
</blockquote>
<p>当文本被点击以后调用此回调函数。</p>
<blockquote>
<p>selectable function </p>
</blockquote>
<p>决定用户是否可以长按选择文本，以便复制和粘贴。</p>
<blockquote>
<p>style style<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">View#style...</div><div class="line">color string</div><div class="line">fontFamily string</div><div class="line">fontSize number</div><div class="line">fontStyle enum(&apos;normal&apos;, &apos;italic&apos;)</div><div class="line">fontWeight enum(&quot;normal&quot;, &apos;bold&apos;, &apos;100&apos;, &apos;200&apos;, &apos;300&apos;, &apos;400&apos;, &apos;500&apos;, &apos;600&apos;, &apos;700&apos;, &apos;800&apos;, &apos;900&apos;)</div><div class="line">指定字体的粗细。大多数字体都支持&apos;normal&apos;和&apos;bold&apos;值。并非所有字体都支持所有的数字值。如果某个值不支持，则会自动选择最接近的值。</div><div class="line">letterSpacing number</div><div class="line">lineHeight number</div><div class="line">textAlign enum(&quot;auto&quot;, &apos;left&apos;, &apos;right&apos;, &apos;center&apos;, &apos;justify&apos;)</div><div class="line">指定文本的对齐方式。其中&apos;justify&apos;值仅iOS支持。</div><div class="line">android textAlignVertical enum(&apos;auto&apos;, &apos;top&apos;, &apos;bottom&apos;, &apos;center&apos;)</div><div class="line">ios letterSpacing number</div><div class="line">ios textDecorationColor string</div><div class="line">textDecorationLine enum(&quot;none&quot;, &apos;underline&apos;, &apos;line-through&apos;, &apos;underline line-through&apos;)</div><div class="line">ios textDecorationStyle enum(&quot;solid&quot;, &apos;double&apos;, &apos;dotted&apos;, &apos;dashed&apos;)</div><div class="line">ios writingDirection enum(&quot;auto&quot;, &apos;ltr&apos;, &apos;rtl&apos;)</div></pre></td></tr></table></figure></p>
<p>testID string </p>
</blockquote>
<p>用来在端到端测试中标记这个视图。</p>
<h2 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h2><p>TextInput是一个允许用户输入文本的基础组件。它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。<br>另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">text</span>: <span class="string">''</span>&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;padding:</span> <span class="attr">10</span>&#125;&#125;&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">TextInput</span></span></div><div class="line">          <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> <span class="attr">40</span>&#125;&#125;</div><div class="line">          <span class="attr">placeholder</span>=<span class="string">"Type here to translate!"</span></div><div class="line">          <span class="attr">onChangeText</span>=<span class="string">&#123;(text)</span> =&gt; this.setState(&#123;text&#125;)&#125;</div><div class="line">        /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;padding:</span> <span class="attr">10</span>, <span class="attr">fontSize:</span> <span class="attr">42</span>&#125;&#125;&gt;</span></div><div class="line">          &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '🍕').join(' ')&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>autoCapitalize enum(‘none’, ‘sentences’, ‘words’, ‘characters’) </p>
</blockquote>
<p>控制TextInput是否要自动将特定字符切换为大写：</p>
<p>characters: 所有的字符。<br>words: 每个单词的第一个字符。<br>sentences: 每句话的第一个字符（默认）。<br>none: 不自动切换任何字符为大写。  </p>
<blockquote>
<p>autoCorrect bool </p>
</blockquote>
<p>如果为false，会关闭拼写自动修正。默认值是true。</p>
<blockquote>
<p>autoFocus bool </p>
</blockquote>
<p>如果为true，在componentDidMount后会获得焦点。默认值为false。</p>
<blockquote>
<p>blurOnSubmit bool </p>
</blockquote>
<p>如果为true，文本框会在提交的时候失焦。对于单行输入框默认值为true，多行则为false。注意：对于多行输入框来说，如果将blurOnSubmit设为true，则在按下回车键时就会失去焦点同时触发onSubmitEditing事件，而不会换行。</p>
<blockquote>
<p>defaultValue string </p>
</blockquote>
<p>提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。</p>
<p>在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。</p>
<blockquote>
<p>editable bool </p>
</blockquote>
<p>如果为false，文本框是不可编辑的。默认值为true。</p>
<blockquote>
<p>keyboardType enum(“default”, ‘numeric’, ‘email-address’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘phone-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) </p>
</blockquote>
<p>决定弹出的何种软键盘的，譬如numeric（纯数字键盘）。</p>
<p>这些值在所有平台都可用：</p>
<p>default<br>numeric<br>email-address</p>
<blockquote>
<p>maxLength number </p>
</blockquote>
<p>限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。</p>
<blockquote>
<p>multiline bool </p>
</blockquote>
<p>如果为true，文本框中可以输入多行文字。默认值为false。</p>
<blockquote>
<p>onBlur function </p>
</blockquote>
<p>当文本框失去焦点的时候调用此回调函数。</p>
<blockquote>
<p>onChange function </p>
</blockquote>
<p>当文本框内容变化时调用此回调函数。</p>
<blockquote>
<p>onChangeText function </p>
</blockquote>
<p>当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。</p>
<blockquote>
<p>onEndEditing function </p>
</blockquote>
<p>当文本输入结束后调用此回调函数。</p>
<blockquote>
<p>onFocus function </p>
</blockquote>
<p>当文本框获得焦点的时候调用此回调函数。</p>
<blockquote>
<p>onLayout function </p>
</blockquote>
<p>当组件挂载或者布局变化的时候调用，参数为{x, y, width, height}。</p>
<blockquote>
<p>onSubmitEditing function </p>
</blockquote>
<p>此回调函数当软键盘的确定/提交按钮被按下的时候调用此函数。如果multiline={true}，此属性不可用。</p>
<blockquote>
<p>placeholder string </p>
</blockquote>
<p>如果没有任何文字输入，会显示此字符串。</p>
<blockquote>
<p>placeholderTextColor string </p>
</blockquote>
<p>占位字符串显示的文字颜色。</p>
<blockquote>
<p>secureTextEntry bool </p>
</blockquote>
<p>如果为true，文本框会遮住之前输入的文字，这样类似密码之类的敏感文字可以更加安全。默认值为false。</p>
<blockquote>
<p>selectTextOnFocus bool </p>
</blockquote>
<p>如果为true，当获得焦点的时候，所有的文字都会被选中。</p>
<blockquote>
<p>selectionColor string </p>
</blockquote>
<p>设置输入框高亮时的颜色（在iOS上还包括光标）</p>
<blockquote>
<p>style Text#style </p>
</blockquote>
<p>译注：这意味着本组件继承了所有Text的样式。</p>
<blockquote>
<p>value string </p>
</blockquote>
<p>文本框中的文字内容。</p>
<p>TextInput是一个受约束的(Controlled)的组件，意味着如果提供了value属性，原生值会被强制与value属性保持一致。在大部分情况下这都工作的很好，不过有些情况下会导致一些闪烁现象——一个常见的原因就是通过不改变value来阻止用户进行编辑。如果你希望阻止用户输入，可以考虑设置editable={false}；如果你是希望限制输入的长度，可以考虑设置maxLength属性，这两个属性都不会导致闪烁。</p>
<blockquote>
<p>ios clearButtonMode enum(‘never’, ‘while-editing’, ‘unless-editing’, ‘always’) </p>
</blockquote>
<p>是否要在文本框右侧显示“清除”按钮。</p>
<blockquote>
<p>ios clearTextOnFocus bool </p>
</blockquote>
<p>如果为true，每次开始输入的时候都会清除文本框的内容。</p>
<blockquote>
<p>ios enablesReturnKeyAutomatically bool </p>
</blockquote>
<p>如果为true，键盘会在文本框内没有文字的时候禁用确认按钮。默认值为false。</p>
<blockquote>
<p>ios keyboardAppearance enum(‘default’, ‘light’, ‘dark’) </p>
</blockquote>
<p>指定键盘的颜色。</p>
<blockquote>
<p>ios onKeyPress function </p>
</blockquote>
<p>当一个键被按下的时候调用此回调。被按下的键会作为参数传递给回调函数。会在onChange之前调用。</p>
<blockquote>
<p>ios returnKeyType enum(‘default’, ‘go’, ‘google’, ‘join’, ‘next’, ‘route’, ‘search’, ‘send’, ‘yahoo’, ‘done’, ‘emergency-call’)</p>
</blockquote>
<p>决定“确定”按钮显示的内容。</p>
<blockquote>
<p>ios selectionState DocumentSelectionState </p>
</blockquote>
<p>参见DocumentSelectionState.js，可以控制一个文档中哪段文字被选中的状态。</p>
<blockquote>
<p>android numberOfLines number </p>
</blockquote>
<p>设置输入框的行数。当multiline设置为true时使用它，可以占据对应的行数。</p>
<blockquote>
<p>android underlineColorAndroid string </p>
</blockquote>
<p>文本框的下划线颜色(译注：如果要去掉文本框的边框，请将此属性设为透明transparent)。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>isFocused(): boolean #</p>
</blockquote>
<p>返回值表明当前输入框是否获得了焦点。</p>
<blockquote>
<p>clear() </p>
</blockquote>
<p>清空输入框的内容。</p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。<br>ScrollView不仅可以垂直滚动，还能水平滚动（通过horizontal属性来设置）。<br>ScrollView适合用来显示数量不多的滚动元素。</p>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>contentContainerStyle StyleSheetPropType(ViewStylePropTypes) </p>
</blockquote>
<p>这些样式会应用到一个内层的内容容器上，所有的子视图都会包裹在内容容器内。例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">contentContainerStyle</span>=<span class="string">&#123;styles.contentContainer&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></div><div class="line">  );</div><div class="line">  ...</div><div class="line">  var styles = StyleSheet.create(&#123;</div><div class="line">    <span class="attr">contentContainer</span>: &#123;</div><div class="line">      <span class="attr">paddingVertical</span>: <span class="number">20</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>horizontal bool </p>
</blockquote>
<p>当此属性为true的时候，所有的的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p>
<blockquote>
<p>keyboardDismissMode enum(‘none’, “interactive”, ‘on-drag’) </p>
</blockquote>
<p>用户拖拽滚动视图的时候，是否要隐藏软键盘。</p>
<p>none（默认值），拖拽时不隐藏软键盘。</p>
<p>on-drag 当拖拽开始的时候隐藏软键盘。</p>
<p>interactive 软键盘伴随拖拽操作同步地消失，并且如果往上滑动会恢复键盘。安卓设备上不支持这个选项，会表现的和none一样。</p>
<blockquote>
<p>keyboardShouldPersistTaps bool </p>
</blockquote>
<p>当此属性为false的时候，在软键盘激活之后，点击焦点文本输入框以外的地方，键盘就会隐藏。如果为true，滚动视图不会响应点击操作，并且键盘不会自动消失。默认值为false。</p>
<blockquote>
<p>onContentSizeChange function </p>
</blockquote>
<p>此函数会在ScrollView内部可滚动内容的视图发生变化时调用。</p>
<p>调用参数为内容视图的宽和高: (contentWidth, contentHeight)</p>
<p>此方法是通过绑定在内容容器上的onLayout来实现的。</p>
<blockquote>
<p>onScroll function </p>
</blockquote>
<p>在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。</p>
<blockquote>
<p>refreshControl element </p>
</blockquote>
<p>指定RefreshControl组件，用于为ScrollView提供下拉刷新功能。</p>
<blockquote>
<p>removeClippedSubviews bool #</p>
</blockquote>
<p>（实验特性）：当此属性为true时，屏幕之外的子视图（子视图的overflow样式需要设为hidden）会被移除。这个可以提升大列表的滚动性能。默认值为true。</p>
<blockquote>
<p>showsHorizontalScrollIndicator bool </p>
</blockquote>
<p>当此属性为true的时候，显示一个水平方向的滚动条。</p>
<blockquote>
<p>showsVerticalScrollIndicator bool </p>
</blockquote>
<p>当此属性为true的时候，显示一个垂直方向的滚动条。</p>
<blockquote>
<p>pagingEnabled bool </p>
</blockquote>
<p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p>
<blockquote>
<p>scrollEnabled bool </p>
</blockquote>
<p>当值为false的时候，内容不能滚动，默认值为true。</p>
<blockquote>
<p>style属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Flexbox...</div><div class="line">ShadowProp#style...</div><div class="line">Transforms...</div><div class="line">backfaceVisibility enum(&apos;visible&apos;, &apos;hidden&apos;)</div><div class="line">backgroundColor string</div><div class="line">borderColor string</div><div class="line">borderTopColor string</div><div class="line">borderRightColor string</div><div class="line">borderBottomColor string</div><div class="line">borderLeftColor string</div><div class="line">borderRadius number</div><div class="line">borderTopLeftRadius number</div><div class="line">borderTopRightRadius number</div><div class="line">borderBottomLeftRadius number</div><div class="line">borderBottomRightRadius number</div><div class="line">borderStyle enum(&apos;solid&apos;, &apos;dotted&apos;, &apos;dashed&apos;)</div><div class="line">borderWidth number</div><div class="line">borderTopWidth number</div><div class="line">borderRightWidth number</div><div class="line">borderBottomWidth number</div><div class="line">borderLeftWidth number</div><div class="line">opacity number</div><div class="line">overflow enum(&apos;visible&apos;, &apos;hidden&apos;)</div><div class="line">shadowColor string</div><div class="line">shadowOffset &#123;width: number, height: number&#125;</div><div class="line">shadowOpacity number</div><div class="line">shadowRadius number</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>scrollTo(y: number | { x?: number, y?: number, animated?: boolean }, x: number, animated: boolean) </p>
</blockquote>
<p>滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。<br>使用示例:<br>scrollTo({x: 0, y: 0, animated: true})</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>ListView组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>ListView更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，ListView并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。<br>ListView最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组，<br>再使用数据源来实例化一个ListView组件，并且定义它的renderRow回调函数，这个函数会接受数组中的每个数据作为参数，返回一个可渲染的组件（作为listview的每一行）。<br>rowHasChanged函数也是ListView的必需属性。(===符号只比较基本类型数据的值，和引用类型的地址)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">var</span> ds = <span class="keyword">new</span> ListView.DataSource(&#123;<span class="attr">rowHasChanged</span>: <span class="function">(<span class="params">r1, r2</span>) =&gt;</span> r1 !== r2&#125;);</div><div class="line">  <span class="keyword">this</span>.state = &#123;</div><div class="line">    <span class="attr">dataSource</span>: ds.cloneWithRows([<span class="string">'row 1'</span>, <span class="string">'row 2'</span>]),</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ListView</span></span></span></div><div class="line">      <span class="attr">dataSource</span>=<span class="string">&#123;this.state.dataSource&#125;</span></div><div class="line">      <span class="attr">renderRow</span>=<span class="string">&#123;(rowData)</span> =&gt; <span class="tag">&lt;<span class="name">Text</span>&gt;</span>&#123;rowData&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span>&#125;</div><div class="line">    /&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ListView还支持一些高级特性，譬如给每段/组(section)数据添加一个带有粘性的头部（类似iPhone的通讯录，其首字母会在滑动过程中吸附在屏幕上方）；<br>在列表头部和尾部增加单独的内容；在到达列表尾部的时候调用回调函数(onEndReached)，还有在视野内可见的数据变化时调用回调函数(onChangeVisibleRows)，<br>以及一些性能方面的优化。<br>有一些性能优化使得ListView可以滚动的更加平滑，尤其是在动态加载可能很大（或者概念上无限长的）数据集的时候：  </p>
<ul>
<li>只更新变化的行 - 提供给数据源的rowHasChanged函数可以告诉ListView它是否需要重绘一行数据（即：数据是否发生了变化）参见ListViewDataSource</li>
<li>限制频率的行渲染 - 默认情况下，每次消息循环只有一行会被渲染（可以用pageSize属性配置）。这把较大的工作分散成小的碎片，以降低因为渲染而导致丢帧的可能性。</li>
</ul>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>ScrollView props… </p>
</blockquote>
<p>ListView可以使用所有ScrollView的属性。</p>
<blockquote>
<p>dataSource ListViewDataSource </p>
</blockquote>
<p>ListView.DataSource实例（列表依赖的数据源）</p>
<blockquote>
<p>initialListSize number </p>
</blockquote>
<p>指定在组件刚挂载的时候渲染多少行数据。用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来。</p>
<blockquote>
<p>onChangeVisibleRows function </p>
</blockquote>
<p>(visibleRows, changedRows) =&gt; void</p>
<p>当可见的行的集合变化的时候调用此回调函数。visibleRows 以 { sectionID: { rowID: true }}的格式包含了所有可见行，而changedRows 以{ sectionID: { rowID: true | false }}的格式包含了所有刚刚改变了可见性的行，其中如果值为true表示一个行变得可见，而为false表示行刚刚离开可视区域而变得不可见。</p>
<blockquote>
<p>onEndReached function </p>
</blockquote>
<p>当所有的数据都已经渲染过，并且列表被滚动到距离最底部不足onEndReachedThreshold个像素的距离时调用。原生的滚动事件会被作为参数传递。译注：当第一次渲染时，如果数据不足一屏（比如初始值是空的），这个事件也会被触发，请自行做标记过滤。</p>
<blockquote>
<p>onEndReachedThreshold number </p>
</blockquote>
<p>调用onEndReached之前的临界值，单位是像素。</p>
<blockquote>
<p>pageSize number </p>
</blockquote>
<p>每次事件循环（每帧）渲染的行数。</p>
<blockquote>
<p>removeClippedSubviews bool </p>
</blockquote>
<p>用于提升大列表的滚动性能。需要给行容器添加样式overflow:’hidden’。（Android已默认添加此样式）。此属性默认开启。</p>
<blockquote>
<p>renderFooter function </p>
</blockquote>
<p>() =&gt; renderable</p>
<p>页头与页脚会在每次渲染过程中都重新渲染（如果提供了这些属性）。如果它们重绘的性能开销很大，把他们包装到一个StaticContainer或者其它恰当的结构中。页脚会永远在列表的最底部，而页头会在最顶部。</p>
<blockquote>
<p>renderHeader function </p>
<p>renderRow function </p>
</blockquote>
<p>(rowData, sectionID, rowID, highlightRow) =&gt; renderable</p>
<p>从数据源(Data source)中接受一条数据，以及它和它所在section的ID。返回一个可渲染的组件来为这行数据进行渲染。默认情况下参数中的数据就是放进数据源中的数据本身，不过也可以提供一些转换器。</p>
<p>如果某一行正在被高亮（通过调用highlightRow函数），ListView会得到相应的通知。当一行被高亮时，其两侧的分割线会被隐藏。行的高亮状态可以通过调用highlightRow(null)来重置。</p>
<blockquote>
<p>renderScrollComponent function </p>
</blockquote>
<p>(props) =&gt; renderable</p>
<p>指定一个函数，在其中返回一个可以滚动的组件。ListView将会在该组件内部进行渲染。默认情况下会返回一个包含指定属性的ScrollView。</p>
<blockquote>
<p>renderSectionHeader function </p>
</blockquote>
<p>(sectionData, sectionID) =&gt; renderable</p>
<p>如果提供了此函数，会为每个小节(section)渲染一个粘性的标题。</p>
<p>粘性是指当它刚出现时，会处在对应小节的内容顶部；继续下滑当它到达屏幕顶端的时候，它会停留在屏幕顶端，一直到对应的位置被下一个小节的标题占据为止。</p>
<blockquote>
<p>renderSeparator function </p>
</blockquote>
<p>(sectionID, rowID, adjacentRowHighlighted) =&gt; renderable</p>
<p>如果提供了此属性，一个可渲染的组件会被渲染在每一行下面，除了小节标题的前面的最后一行。在其上方的小节ID和行ID，以及邻近的行是否被高亮会作为参数传递进来。</p>
<blockquote>
<p>scrollRenderAheadDistance number </p>
</blockquote>
<p>当一个行接近屏幕范围多少像素之内的时候，就开始渲染这一行。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>getMetrics() </p>
</blockquote>
<p>导出一些用于性能分析的数据。</p>
<blockquote>
<p>scrollTo(…args) </p>
</blockquote>
<p>滚动到指定的x, y偏移处，可以指定是否加上过渡动画。<br>参考:ScrollView#scrollTo.</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="使用Fetch"><a href="#使用Fetch" class="headerlink" title="使用Fetch"></a>使用Fetch</h3><p>React Native提供了和web标准一致的Fetch API，用于满足开发者访问网络的需求。</p>
<blockquote>
<p>发起网络请求</p>
</blockquote>
<p>要从任意地址获取内容的话，只需简单地将网址作为参数传递给fetch方法即可（fetch这个词本身也就是获取的意思）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'https://mywebsite.com/mydata.json'</span>)</div></pre></td></tr></table></figure>
<p>Fetch还有可选的第二个参数，可以用来定制HTTP请求一些参数。你可以指定header参数，或是指定使用POST方法，又或是提交数据等等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'https://mywebsite.com/endpoint/'</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</div><div class="line">    <span class="attr">firstParam</span>: <span class="string">'yourValue'</span>,</div><div class="line">    <span class="attr">secondParam</span>: <span class="string">'yourOtherValue'</span>,</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果你的服务器无法识别上面POST的数据格式，那么可以尝试传统的form格式，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'https://mywebsite.com/endpoint/'</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="string">'key1=value1&amp;key2=value2'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以参考Fetch请求文档来查看所有可用的参数。</p>
<blockquote>
<p>处理服务器的响应数据</p>
</blockquote>
<p>网络请求天然是一种异步操作。Fetch 方法会返回一个Promise，这种模式可以简化异步风格的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">getMoviesFromApiAsync() &#123;</div><div class="line">  <span class="keyword">return</span> fetch(<span class="string">'http://facebook.github.io/react-native/movies.json'</span>)</div><div class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</div><div class="line">    .then(<span class="function">(<span class="params">responseJson</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> responseJson.movies;</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.error(error);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在React Native应用中使用ES7标准中的async/await 语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这个方法前面有async关键字</span></div><div class="line"><span class="keyword">async</span> getMoviesFromApi() &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 注意这里的await语句，其所在的函数必须有async关键字声明</span></div><div class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'http://facebook.github.io/react-native/movies.json'</span>);</div><div class="line">    <span class="keyword">let</span> responseJson = <span class="keyword">await</span> response.json();</div><div class="line">    <span class="keyword">return</span> responseJson.movies;</div><div class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</div><div class="line">    <span class="built_in">console</span>.error(error);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>别忘了catch住fetch可能抛出的异常，否则出错时你可能看不到任何提示。</p>
<h3 id="使用其他的网络库"><a href="#使用其他的网络库" class="headerlink" title="使用其他的网络库"></a>使用其他的网络库</h3><p>React Native中已经内置了XMLHttpRequest API(也就是俗称的ajax)。一些基于XMLHttpRequest封装的第三方库也可以使用，<br>例如frisbee或是axios等。但注意不能使用jQuery，因为jQuery中还使用了很多浏览器中才有而RN中没有的东西（所以也不是所有web中的ajax库都可以直接使用）。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>React Native还支持WebSocket，这种协议可以在单个TCP连接上提供全双工的通信信道。<br>WebSocket一开始的握手需要借助HTTP请求完成，可以实现实时通讯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://host.com/path'</span>);</div><div class="line"></div><div class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 打开一个连接</span></div><div class="line">  ws.send(<span class="string">'something'</span>); <span class="comment">// 发送一个消息</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">ws.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 接收到了一个消息</span></div><div class="line">  <span class="built_in">console</span>.log(e.data);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ws.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 发生了一个错误</span></div><div class="line">  <span class="built_in">console</span>.log(e.message);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ws.onclose = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 连接被关闭了</span></div><div class="line">  <span class="built_in">console</span>.log(e.code, e.reason);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="导航器"><a href="#导航器" class="headerlink" title="导航器"></a>导航器</h1><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><h3 id="场景（Scene）的概念与使用"><a href="#场景（Scene）的概念与使用" class="headerlink" title="场景（Scene）的概念与使用"></a>场景（Scene）的概念与使用</h3><p>无论是View中包含Text，还是一个排满了图片的ScrollView，渲染各种组件现在对你来说应该已经得心应手了。<br>这些摆放在一个屏幕中的组件，就共同构成了一个“场景（Scene）”。场景简单来说其实就是一个全屏的React组件。</p>
<p>下面定义了一个仅显示一些文本的简单场景：</p>
<blockquote>
<p>MyScene.js：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; View, Text &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScene</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> defaultProps = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'MyScene'</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hi! My name is &#123;this.props.title&#125;.<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#D96060"><br>注意:组件声明前面的export default关键字。它的意思是导出(export)当前组件，以允许其他组件引入(import)和使用当前组件。<br></font>

<blockquote>
<p>index.android.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="comment">// ./MyScene表示的是当前目录下的MyScene.js文件</span></div><div class="line"><span class="comment">// 注意即便当前文件和MyScene.js在同一个目录中，"./"两个符号也是不能省略的！</span></div><div class="line"><span class="comment">// 但是.js后缀是可以省略的</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> MyScene <span class="keyword">from</span> <span class="string">'./MyScene'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoDawgApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">MyScene</span> /&gt;</span></span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>
<p>我们现在已经创建了只有单个场景的App。其中的MyScene同时也是一个可复用的Reac组件的例子。</p>
<h3 id="使用Navigator"><a href="#使用Navigator" class="headerlink" title="使用Navigator"></a>使用Navigator</h3><p>下面我们开始尝试导航跳转。首先要做的是渲染一个Navigator组件，然后通过此组件的renderScene属性方法来渲染其他场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;Navigator</div><div class="line">      initialRoute=&#123;&#123; title: 'My Initial Scene', index: 0 &#125;&#125;</div><div class="line">      renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class="line">        return &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class="line">      &#125;&#125;</div><div class="line">    /&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。<br>renderScene方法是完全根据路由提供的信息来渲染场景的，你可以在路由中任意自定义参数以区分标记不同的场景。</p>
<h4 id="将场景推入导航栈"><a href="#将场景推入导航栈" class="headerlink" title="将场景推入导航栈"></a>将场景推入导航栈</h4><p>要过渡到新的场景，你需要了解push和pop方法。这两个方法由navigator对象提供，而这个对象就是上面的renderScene方法中传递的第二个参数。<br>我们使用这两个方法来把路由对象推入或弹出导航栈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">navigator.push(&#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">'Next Scene'</span>,</div><div class="line">  <span class="attr">index</span>: <span class="number">1</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">navigator.pop();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRegistry, Navigator, Text, View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> MyScene <span class="keyword">from</span> <span class="string">'./MyScene'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNavigationApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;Navigator</div><div class="line">        initialRoute=&#123;&#123; title: 'My Initial Scene', index: 0 &#125;&#125;</div><div class="line">        renderScene=&#123;(route, navigator) =&gt;</div><div class="line">          &lt;MyScene</div><div class="line">            title=&#123;route.title&#125;</div><div class="line"></div><div class="line">            // 调用这个函数显示一个新的场景           </div><div class="line">            onForward=&#123; () =&gt; &#123;    </div><div class="line">              const nextIndex = route.index + 1;</div><div class="line">              navigator.push(&#123;</div><div class="line">                title: 'Scene ' + nextIndex,</div><div class="line">                index: nextIndex,</div><div class="line">              &#125;);</div><div class="line">            &#125;&#125;</div><div class="line"></div><div class="line">            // 调用这个函数回到当前场景</div><div class="line">            onBack=&#123;() =&gt; &#123;</div><div class="line">              if (route.index &gt; 0) &#123;</div><div class="line">                navigator.pop();</div><div class="line">              &#125;</div><div class="line">            &#125;&#125;</div><div class="line">          /&gt;</div><div class="line">        &#125;</div><div class="line">      /&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AppRegistry.registerComponent('SimpleNavigationApp', () =&gt; SimpleNavigationApp);</div></pre></td></tr></table></figure>
<blockquote>
<p>MyScene.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; View, Text, TouchableHighlight &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScene</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> propTypes = &#123;</div><div class="line">    <span class="attr">title</span>: PropTypes.string.isRequired,</div><div class="line">    <span class="attr">onForward</span>: PropTypes.func.isRequired,</div><div class="line">    <span class="attr">onBack</span>: PropTypes.func.isRequired,</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Current Scene: &#123; this.props.title &#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">TouchableHighlight</span> <span class="attr">onPress</span>=<span class="string">&#123;this.props.onForward&#125;</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Text</span>&gt;</span>点我进入下一场景<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">TouchableHighlight</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">TouchableHighlight</span> <span class="attr">onPress</span>=<span class="string">&#123;this.props.onBack&#125;</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Text</span>&gt;</span>点我返回上一场景<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">TouchableHighlight</span>&gt;</span>    </div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MyScene通过title属性接受了路由对象中的title值。它还包含了两个可点击的组件TouchableHighlight，<br>会在点击时分别调用通过props传入的onForward和onBack方法，而这两个方法各自调用了navigator.push()和navigator.pop()，从而实现了场景的变化。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://cokernut.top/2016/12/01/ReactNative/React Native学习笔记--基础知识/" data-id="ciw7jh9fc001skculjfu45txm" class="article-share-link" data-share="baidu" data-title="React Native 学习笔记--基础知识">分享到</a>
      

      
        <a href="http://cokernut.top/2016/12/01/ReactNative/React Native学习笔记--基础知识/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-Native/">React Native</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/11/29/Note/使用Hexo+GitHub Pages搭建静态博客/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">使用Hexo+GitHub Pages搭建静态博客</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2016/12/01/ReactNative/React Native学习笔记--基础知识/" data-title="React Native 学习笔记--基础知识" data-url="http://cokernut.top/2016/12/01/ReactNative/React Native学习笔记--基础知识/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/React-Native/">React Native</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GitHub/">GitHub</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown/">MarkDown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/cokernut/" target="_blank">GitHub</a>
          </li>
        
          <li>
            <a href="http://blog.csdn.net/u011965040/" target="_blank">CSDN</a>
          </li>
        
          <li>
            <a href="https://github.com/cokernut/Documents/" target="_blank">Documents</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AccessibilityService/">AccessibilityService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/">GitHub</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python3/">Python3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recyclerview/">Recyclerview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebView/">WebView</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/01/ReactNative/React Native学习笔记--基础知识/">React Native 学习笔记--基础知识</a>
          </li>
        
          <li>
            <a href="/2016/11/29/Note/使用Hexo+GitHub Pages搭建静态博客/">使用Hexo+GitHub Pages搭建静态博客</a>
          </li>
        
          <li>
            <a href="/2016/11/25/Android/React Native嵌入Android原生项目中/">React Native嵌入Android原生项目中</a>
          </li>
        
          <li>
            <a href="/2016/11/23/Android/React Native for Android Windows环境搭建/">React Native for Android Windows环境搭建</a>
          </li>
        
          <li>
            <a href="/2016/11/17/Android/Android辅助功能AccessibilityService的使用/">Android辅助功能AccessibilityService的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AccessibilityService/" style="font-size: 10px;">AccessibilityService</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/MarkDown/" style="font-size: 10px;">MarkDown</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Python3/" style="font-size: 10px;">Python3</a> <a href="/tags/React-Native/" style="font-size: 15px;">React Native</a> <a href="/tags/Recyclerview/" style="font-size: 10px;">Recyclerview</a> <a href="/tags/WebView/" style="font-size: 10px;">WebView</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016年 12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016年 11月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016年 10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">2016年 09月</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  <!--不蒜子网页计数器-->
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <font size="2">
      &copy; 2016 Cokernut&nbsp;&nbsp;|&nbsp;&nbsp;
      <span id="busuanzi_container_site_pv">您是本站的第 <font color="#00A2E8"><span id="busuanzi_value_site_pv"></span></font> 位访客。</span>
      </font>
      <br>
      <a href="/sitemap.xml">Sitemap</a>&nbsp; &nbsp; | &nbsp; &nbsp; 
			<a href="/atom.xml">RSS</a>&nbsp; &nbsp; | &nbsp; &nbsp;
			<a href="Mailto:cokernut@foxmail.com" target="_blank">联系博主</a>&nbsp; &nbsp;
      <br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">目录</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"cokernut"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>



<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
